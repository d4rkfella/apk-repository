--- chromaprint/src/audio/ffmpeg_audio_reader.h	2025-04-24 02:39:36.037092483 +0300
+++ chromaprint/src/audio/ffmpeg_audio_reader.h	2025-04-24 02:39:42.901007232 +0300
@@ -30,8 +30,22 @@
 	FFmpegAudioReader();
 	~FFmpegAudioReader();
 
+	/**
+	 * Get the sample rate in the audio stream.
+	 * @return sample rate in Hz, -1 on error
+	 */
 	int GetSampleRate() const;
+
+	/**
+	 * Get the number of channels in the audio stream.
+	 * @return number of channels, -1 on error
+	 */
 	int GetChannels() const;
+
+	/**
+	 * Get the estimated audio stream duration.
+	 * @return stream duration in milliseconds, -1 on error
+	 */
 	int GetDuration() const;
 
 	bool SetInputFormat(const char *name);
@@ -42,6 +56,7 @@
 	void SetOutputChannels(int channels) { m_output_channels = channels; }
 
 	bool Open(const std::string &file_name);
+
 	void Close();
 
 	bool Read(const int16_t **data, size_t *size);
@@ -72,6 +87,7 @@
 	bool m_opened = false;
 	int m_got_frame = 0;
 	AVPacket m_packet;
+	AVPacket m_packet0;
 
 	int m_output_sample_rate = 0;
 	int m_output_channels = 0;
@@ -82,16 +98,19 @@
 
 inline FFmpegAudioReader::FFmpegAudioReader() {
 	av_log_set_level(AV_LOG_QUIET);
+
 	av_init_packet(&m_packet);
 	m_packet.data = nullptr;
 	m_packet.size = 0;
+
+	m_packet0 = m_packet;
 }
 
 inline FFmpegAudioReader::~FFmpegAudioReader() {
 	Close();
 	av_dict_free(&m_input_opts);
 	av_freep(&m_convert_buffer[0]);
-	av_packet_unref(&m_packet);
+	av_packet_unref(&m_packet0);
 }
 
 inline bool FFmpegAudioReader::SetInputFormat(const char *name) {
@@ -116,6 +135,12 @@
 
 	Close();
 
+    av_init_packet(&m_packet);
+	m_packet.data = nullptr;
+	m_packet.size = 0;
+
+	m_packet0 = m_packet;
+
 	ret = avformat_open_input(&m_format_ctx, file_name.c_str(), m_input_fmt, &m_input_opts);
 	if (ret < 0) {
 		SetError("Could not open the input file", ret);
@@ -124,67 +149,56 @@
 
 	ret = avformat_find_stream_info(m_format_ctx, nullptr);
 	if (ret < 0) {
-		SetError("Could not find stream information", ret);
+		SetError("Coud not find stream information in the file", ret);
 		return false;
 	}
 
-	const AVCodec *codec;
+	AVCodec *codec;
 	ret = av_find_best_stream(m_format_ctx, AVMEDIA_TYPE_AUDIO, -1, -1, &codec, 0);
 	if (ret < 0) {
-		SetError("Could not find any audio stream", ret);
+		SetError("Could not find any audio stream in the file", ret);
 		return false;
 	}
 	m_stream_index = ret;
 
-	m_codec_ctx = avcodec_alloc_context3(codec);
-	if (!m_codec_ctx) {
-		SetError("Failed to allocate codec context");
-		return false;
-	}
-
-	ret = avcodec_parameters_to_context(m_codec_ctx, m_format_ctx->streams[m_stream_index]->codecpar);
-	if (ret < 0) {
-		SetError("Failed to copy codec parameters to decoder context", ret);
-		return false;
-	}
-
+	m_codec_ctx = m_format_ctx->streams[m_stream_index]->codec;
 	m_codec_ctx->request_sample_fmt = AV_SAMPLE_FMT_S16;
 
 	ret = avcodec_open2(m_codec_ctx, codec, nullptr);
 	if (ret < 0) {
-		SetError("Could not open codec", ret);
+		SetError("Could not open the codec", ret);
 		return false;
 	}
 
-	if (!m_codec_ctx->ch_layout.nb_channels) {
-		av_channel_layout_default(&m_codec_ctx->ch_layout, m_codec_ctx->channels);
+	if (!m_codec_ctx->channel_layout) {
+		m_codec_ctx->channel_layout = av_get_default_channel_layout(m_codec_ctx->channels);
 	}
 
 	m_frame = av_frame_alloc();
 	if (!m_frame) {
-		SetError("Could not allocate audio frame");
 		return false;
 	}
 
 	if (!m_output_sample_rate) {
 		m_output_sample_rate = m_codec_ctx->sample_rate;
 	}
+
 	if (!m_output_channels) {
-		m_output_channels = m_codec_ctx->ch_layout.nb_channels;
+		m_output_channels = m_codec_ctx->channels;
 	}
 
-	if (m_codec_ctx->sample_fmt != AV_SAMPLE_FMT_S16 || m_codec_ctx->sample_rate != m_output_sample_rate || m_codec_ctx->ch_layout.nb_channels != m_output_channels) {
+	if (m_codec_ctx->sample_fmt != AV_SAMPLE_FMT_S16 || m_codec_ctx->channels != m_output_channels || m_codec_ctx->sample_rate != m_output_sample_rate) {
 		m_converter.reset(new FFmpegAudioProcessor());
 		m_converter->SetCompatibleMode();
 		m_converter->SetInputSampleFormat(m_codec_ctx->sample_fmt);
 		m_converter->SetInputSampleRate(m_codec_ctx->sample_rate);
-		m_converter->SetInputChannelLayout(av_get_default_channel_layout(m_codec_ctx->ch_layout.nb_channels));
+		m_converter->SetInputChannelLayout(m_codec_ctx->channel_layout);
 		m_converter->SetOutputSampleFormat(AV_SAMPLE_FMT_S16);
 		m_converter->SetOutputSampleRate(m_output_sample_rate);
 		m_converter->SetOutputChannelLayout(av_get_default_channel_layout(m_output_channels));
-		ret = m_converter->Init();
+		auto ret = m_converter->Init();
 		if (ret != 0) {
-			SetError("Could not initialize audio converter", ret);
+			SetError("Could not create an audio converter instance", ret);
 			return false;
 		}
 	}
@@ -199,16 +213,18 @@
 }
 
 inline void FFmpegAudioReader::Close() {
-	if (m_frame) {
-		av_frame_free(&m_frame);
-	}
+	av_frame_free(&m_frame);
+
+	m_stream_index = -1;
+
 	if (m_codec_ctx) {
-		avcodec_free_context(&m_codec_ctx);
+		avcodec_close(m_codec_ctx);
+		m_codec_ctx = nullptr;
 	}
+
 	if (m_format_ctx) {
 		avformat_close_input(&m_format_ctx);
 	}
-	m_stream_index = -1;
 }
 
 inline int FFmpegAudioReader::GetSampleRate() const {
@@ -221,7 +237,7 @@
 
 inline int FFmpegAudioReader::GetDuration() const {
 	if (m_format_ctx && m_stream_index >= 0) {
-		auto stream = m_format_ctx->streams[m_stream_index];
+		const auto stream = m_format_ctx->streams[m_stream_index];
 		if (stream->duration != AV_NOPTS_VALUE) {
 			return 1000 * stream->time_base.num * stream->duration / stream->time_base.den;
 		} else if (m_format_ctx->duration != AV_NOPTS_VALUE) {
@@ -232,63 +248,92 @@
 }
 
 inline bool FFmpegAudioReader::Read(const int16_t **data, size_t *size) {
-	if (!IsOpen() || IsFinished()) return false;
+	if (!IsOpen() || IsFinished()) {
+		return false;
+	}
 
 	int ret;
 	while (true) {
-		if ((ret = av_read_frame(m_format_ctx, &m_packet)) < 0) {
-			if (ret == AVERROR_EOF) {
-				m_finished = true;
+		while (m_packet.size <= 0) {
+			av_packet_unref(&m_packet0);
+			av_init_packet(&m_packet);
+			m_packet.data = nullptr;
+			m_packet.size = 0;
+			ret = av_read_frame(m_format_ctx, &m_packet);
+			if (ret < 0) {
+				if (ret == AVERROR_EOF) {
+					m_finished = true;
+					break;
+				} else {
+					SetError("Error reading from the audio source", ret);
+					return false;
+				}
+			}
+			m_packet0 = m_packet;
+			if (m_packet.stream_index != m_stream_index) {
+				m_packet.data = nullptr;
+				m_packet.size = 0;
 			} else {
-				SetError("Error reading frame", ret);
-				return false;
+				m_nb_packets++;
 			}
-			break;
-		}
-		if (m_packet.stream_index != m_stream_index) {
-			av_packet_unref(&m_packet);
-			continue;
 		}
 
-		ret = avcodec_send_packet(m_codec_ctx, &m_packet);
-		av_packet_unref(&m_packet);
+		ret = avcodec_decode_audio4(m_codec_ctx, m_frame, &m_got_frame, &m_packet);
 		if (ret < 0) {
-			SetError("Error sending packet to decoder", ret);
-			return false;
+			if (m_decode_error) {
+				SetError("Error decoding audio frame", m_decode_error);
+				return false;
+			}
+			m_decode_error = ret;
+			m_packet.data = nullptr;
+			m_packet.size = 0;
+			continue;
 		}
-		break;
-	}
 
-	ret = avcodec_receive_frame(m_codec_ctx, m_frame);
-	if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) return false;
-	if (ret < 0) {
-		SetError("Error receiving frame from decoder", ret);
-		return false;
+		break;
 	}
 
-	m_got_frame = 1;
+	m_decode_error = 0;
 
-	if (m_converter) {
-		if (m_frame->nb_samples > m_convert_buffer_nb_samples) {
-			int linesize;
-			av_freep(&m_convert_buffer[0]);
-			m_convert_buffer_nb_samples = std::max(1024 * 8, m_frame->nb_samples);
-			ret = av_samples_alloc(m_convert_buffer, &linesize, m_output_channels, m_convert_buffer_nb_samples, AV_SAMPLE_FMT_S16, 1);
-			if (ret < 0) {
-				SetError("Failed to allocate conversion buffer", ret);
+	const int decoded = std::min(ret, m_packet.size);
+	m_packet.data += decoded;
+	m_packet.size -= decoded;
+
+	if (m_got_frame) {
+		if (m_converter) {
+			if (m_frame->nb_samples > m_convert_buffer_nb_samples) {
+				int linsize;
+				av_freep(&m_convert_buffer[0]);
+				m_convert_buffer_nb_samples = std::max(1024 * 8, m_frame->nb_samples);
+				ret = av_samples_alloc(m_convert_buffer, &linsize, m_codec_ctx->channels, m_convert_buffer_nb_samples, AV_SAMPLE_FMT_S16, 1);
+				if (ret < 0) {
+					SetError("Couldn't allocate audio converter buffer", ret);
+					return false;
+				}
+			}
+			auto nb_samples = m_converter->Convert(m_convert_buffer, m_convert_buffer_nb_samples, (const uint8_t **) m_frame->data, m_frame->nb_samples);
+			if (nb_samples < 0) {
+				SetError("Couldn't convert audio", ret);
 				return false;
 			}
+			*data = (const int16_t *) m_convert_buffer[0];
+			*size = nb_samples;
+		} else {
+			*data = (const int16_t *) m_frame->data[0];
+			*size = m_frame->nb_samples;
 		}
-		auto nb_samples = m_converter->Convert(m_convert_buffer, m_convert_buffer_nb_samples, (const uint8_t **)m_frame->data, m_frame->nb_samples);
-		if (nb_samples < 0) {
-			SetError("Conversion failed", nb_samples);
-			return false;
-		}
-		*data = (const int16_t *)m_convert_buffer[0];
-		*size = nb_samples;
 	} else {
-		*data = (const int16_t *)m_frame->data[0];
-		*size = m_frame->nb_samples;
+		if (m_finished && m_converter) {
+			auto nb_samples = m_converter->Flush(m_convert_buffer, m_convert_buffer_nb_samples);
+			if (nb_samples < 0) {
+				SetError("Couldn't convert audio", ret);
+				return false;
+			} else if (nb_samples > 0) {
+				m_got_frame = 1;
+				*data = (const int16_t *) m_convert_buffer[0];
+				*size = nb_samples;
+			}
+		}
 	}
 
 	return true;
